<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VESC_Tool基本操作食用指北</title>
      <link href="2021/01/12/VSEC1/"/>
      <url>2021/01/12/VSEC1/</url>
      
        <content type="html"><![CDATA[<p>此教程会随着时间的推移继续更新<br>会把我调VESC轮子中一些比较关键的点写在这里</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><h2 id="一、连接电机和参数标定"><a href="#一、连接电机和参数标定" class="headerlink" title="一、连接电机和参数标定"></a>一、连接电机和参数标定</h2><ol><li>电调USB连接电脑，然后点上位机右上角的连接按钮，当右下角出现“Connected serial to COMXX”字样时，表示电机连接成功。</li></ol><p><img src="https://i.loli.net/2020/12/29/3isByTEd6c4mRPt.jpg" alt="电机连接按钮"></p><p><img src="https://i.loli.net/2020/12/29/4Ul9eYyIVTkZNES.jpg" alt="表示电机连接成功"></p><p>在链接之前，也请记得确认对应的VESC固件的版本号，对应的版本号才可以被对应的VESC_Tool应用控制。<br>在Firmware目录下即可看到对应的Support Firmware是否正确。<br>当然，也有方法进行刷固件操作，这个具体后面会有讲到。</p><p><img src="https://i.loli.net/2021/01/13/Yh6nitLW4pg9BAb.png" alt="版本号查看"></p><ol start="2"><li>然后开始配置电机参数以及传感器参数（下面说的是几个一定要配置的关键参数）：</li></ol><ul><li><p>Motor界面按照电机的重量和电机型号来标定电机类型。注意这里一定要选择正确的电机型号，否则电机要不电压不对炸掉或者出一些奇奇怪怪的问题。<br><img src="https://i.loli.net/2020/12/29/qOKbgor9li1745p.jpg" alt="电机选型界面"></p></li><li><p>Battery界面按照使用的电池进行参数的选择：</p></li><li><p>type：电池类型：锂离子电池/锂铁电池。这里选择锂离子电池，单节电池的电压范围3.0-4.2。</p></li><li><p>cells series：电池串联数：电池是多少s的就填多少。如6s就填6。</p></li><li><p>capacity：电池容量：注意单位是安时。如4500mAh就填0.45Ah。<br><img src="https://i.loli.net/2020/12/29/hWOfXjDLGAMNdvb.jpg" alt="Battery界面"></p></li><li><p>设置这里电机减速比，轮子大小，没有减速箱就选直驱。<br><img src="https://i.loli.net/2020/12/29/E3yg4f7olvpSItc.jpg" alt="电机减速比"></p></li><li><p>下一步就开始测量电机参数，尽量把轮子周围无关的东西拆掉或者远离，以免影响测量，电机参数测量过程中电机会发出噪声属于正常现象。<br><img src="https://i.loli.net/2020/12/29/SPYwfaJb9tZ6iMe.jpg" alt="测量电机参数"></p></li><li><p>这里可以设置电机的正反转方向：<br><img src="https://i.loli.net/2020/12/29/wzQgRdItbYo1AB5.jpg" alt="电机转向"></p></li></ul><h2 id="二、电机值初始化和编码器连接确认"><a href="#二、电机值初始化和编码器连接确认" class="headerlink" title="二、电机值初始化和编码器连接确认"></a>二、电机值初始化和编码器连接确认</h2><ol><li>在调试之前，我们需要先读取之前的适配电机参数，以方便我们进行调试。<br>在Motor &amp; Setting列表下的FOC界面，电机Apply即可读取对应的电机适配参数。<br>计算成功后下面的红色的参数会全部变成绿色。</li></ol><p><img src="https://i.loli.net/2021/01/12/obpryZzRXlKus8J.png" alt="参数配置界面"></p><p>在界面中，有个非常重要的数值就是Sensor Mode，也就是传感器模式。Sensor Mode里面对应的三个参数是：<br>无感模式，最基础的模式，使用电机里面的反电动势有感闭环的时候请选择该模式。<br>编码器模式，接入编码器电机进行闭环的时候请选择该模式。<br>霍尔传感器模式，可以接入霍尔传感器进行闭环的时候请选择该模式。<br>这三个参数对接下来的编码器连接确认的步骤非常有帮助，请务必记下来。<br>同时这个界面还可以帮助我们调整电机的内部自带的PID。</p><p><img src="https://i.loli.net/2021/01/12/GDjk9fIMOdN4wx8.png" alt="传感器模式和PID参数更改对应界面"></p><ol start="2"><li>接下来的就是进行传感器的方式，<br>基于我们实验室用的传感器是AS5047传感器，我们可以通过设置对应的参数来检测传感器是否正确的连接在轮子上。<br>把传感器接上后，选择Motor Settings里面的General设置，并将Sensor Port Mode改为AS5047模式。</li></ol><p><img src="https://i.loli.net/2021/01/12/uaLY8MSfnTGIs3y.png" alt="编码器更改对应界面"></p><p>切换到刚刚的FOC界面，改变对应的模式到Encoder，那么编码器的设置就完全准备好了。<br>成功的设置为的是方便我们，能够在Analysis界面看到对应的波形图上看到Encoder是否配置成功。</p><ol start="3"><li>我们需要查看我们刚刚接入的编码器是否出现问题<br>选择Data Analysis下的Realtime Data选项，会出现对应的显示图表。<br>在中间，我们能看到刚刚的编码器的动态数据栏<br>如果没有出现除了Fault意外的其他状态，那么说明对应的编码器的情况是正常的。<br>同时，在电机后续的测试中，我们可以通过这个界面监控电机的输入电流，电机电流，循环周期等等参数。</li></ol><p><img src="https://i.loli.net/2021/01/12/VZqv5gC3s9zeLPa.png" alt="RTD界面观察编码器是否正常"></p><h2 id="三、电机参数的调整和刷固件的方法"><a href="#三、电机参数的调整和刷固件的方法" class="headerlink" title="三、电机参数的调整和刷固件的方法"></a>三、电机参数的调整和刷固件的方法</h2><ol><li>在Motor Setting下的PID Controller可以在上位机上面对轮子的PID参数进行调节<br>同样的道理，在调整好PID参数之后，直接烧录到电调即可。</li></ol><p><img src="https://i.loli.net/2021/01/13/raOZxto1eCY26p7.png" alt="PID Controller界面"></p><ol start="2"><li>在上面的版本号查看中，我们说过了可以通过刷固件来改变对应控制版本<br>这里我们可以在Firmware界面进行刷固件操作<br>在接入电机并连接之后，选择VESC_default.bin文件，然后点击All进行固件刷取<br>刷取需要一点点的时间，请耐心等待。</li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> VESC Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初战考完研之后的感想</title>
      <link href="2020/12/28/Testing_Feeling/"/>
      <url>2020/12/28/Testing_Feeling/</url>
      
        <content type="html"><![CDATA[<h2 id="考研之后的感受"><a href="#考研之后的感受" class="headerlink" title="考研之后的感受"></a>考研之后的感受</h2><blockquote><p>写给考研之后的我：</p></blockquote><p>这篇文章写在我考研回来之后的那天，也没什么特别的只是想说一下这一次的感受，考研时候的心态，考研完之后的想法，和给应届考研（或者是我的下一次考研）来一点点心理作用和建议。</p><p><img src="https://i.loli.net/2020/12/29/EhO4wsmMNpHjDXy.jpg" alt="因为我这里想放张图所以要放张图"></p><h2 id="第一次考研的感受"><a href="#第一次考研的感受" class="headerlink" title="第一次考研的感受"></a>第一次考研的感受</h2><p>第一次考研，无论是心态上还是行动上给我的感觉都是很大的考研这里我分点来说一下。</p><h3 id="心态方面"><a href="#心态方面" class="headerlink" title="心态方面"></a>心态方面</h3><ul><li><p>心态：具体上就是会出现各种各样奇怪的状态，包括但是不限于：</p><ol><li><p>心态上面的不顺应，你可能会面临着你身边的人都在提升专业方面的水平，而你还在做题，很煎熬的一种感觉。</p></li><li><p>能力方面的不顺应，这个和你学习能力是否强无关，随着时间的逼近，但是你很多题都还是做不太出来的时候，就会感觉很着急。</p></li><li><p>作息上面的不顺应（某些人可能有），比如说我在压力大的时候睡眠质量会差到极致。</p></li></ol></li></ul><h3 id="行动方面"><a href="#行动方面" class="headerlink" title="行动方面"></a>行动方面</h3><ul><li><p>行动：总的来说就是开始的太慢了，由于疫情在家刚开始的时候没想过会放那么久的假期，某种意义上来说都非常的裂开。等回过神来想要复习的时候发现时间已经很赶了，所以应该说要安排好复习的时间。</p></li><li><p>建议在你开始复习的时候每隔一段时间重新规划一次某段时间具体要干什么，具体要怎么干，时间的节点是多少，进度要到什么状态，要做出什么样的调整。毕竟你考研复习的状态下面不知道你什么时候状态怎么样学的多少，计划是要根据你的学习的状态来进行变化的。</p></li><li><p>考研不是说不能玩！考研不是说不能玩！考研不是说不能玩！不会适当放松自己的人才是最蠢的，因为如果你不定时放松自己的话到后期你可能会被学习强度或者自己的压力搞到崩溃。（不要和我说自己的抗压能力很强，你经历过一次你就知道我在说什么了）</p></li><li><p>有一句话叫做玩的时候尽情玩，学的时候拼命学！！放松的时候就好好放松（放松的形式建议是运动或者是带有运动因素的游戏），但是学的时候就要完全集中注意力的学习！</p></li></ul><h3 id="考试科目方面"><a href="#考试科目方面" class="headerlink" title="考试科目方面"></a>考试科目方面</h3><ul><li><p>考试的科目方面：</p><ol><li><p>政治：本质上是考你肯不肯理解和背诵，只要你理解到位了，花时间了，背题目了，你的分数就铁不会差。说白了就是只要你努力了就是线性1：1收货。这个科目是所有科目之后个人认为复习收益比最大的一科，可以用最短的时间提升最多的分数（真话）。</p></li><li><p>英语：本质上是考你的细节，初步抗压能力，以及时间管理能力。英语的考卷基本上是简单-难-简单-难（一般来说），考的就是你到难的那部分的时候会不会跳题，敢不敢跳题，以及简单的题细节上面会不会出问题。</p></li><li><p>数学：数学本质上考的是心态，完整抗压能力，心态调节能力，心里承受能力等。数学是所有科目中我感觉最压抑的一个科目，因为通常来说数学都会比较的难，而实际上也很多人会在数学上面栽跟头。</p></li><li><p>专业科，本质上考你对被打击之后的状态和恢复状态，如果在考完数学之后调整不好自己就会炸(最简单的说法)。实际上考完数学就会走掉一大部分的人。</p></li></ol></li></ul><h3 id="考试动力方面"><a href="#考试动力方面" class="headerlink" title="考试动力方面"></a>考试动力方面</h3><ul><li>考试动力方面：不忘初心，记住你是来考研的基本上就么得问题了。</li><li>最后的最后：最重要的东西，是坚持！坚持！！坚持！！！考试无论是多难你都要考下去，要对得起你自己这一年来付出的努力！！</li></ul><h3 id="考研时间方面"><a href="#考研时间方面" class="headerlink" title="考研时间方面"></a>考研时间方面</h3><ul><li>一年，是刚刚好够，或者说是不太够的，听清楚是不太够的，所以如果要准备的话，需要提前准备好！</li></ul><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>请相信自己，信心是最重要的，同时不变初心！</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研感受 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT_Links 拯救嵌入式利器！Vscode嵌入式完全集成，和Keil说再见</title>
      <link href="2020/01/13/Keil_Assitance/"/>
      <url>2020/01/13/Keil_Assitance/</url>
      
        <content type="html"><![CDATA[<h2 id="发现原因"><a href="#发现原因" class="headerlink" title="发现原因"></a>发现原因</h2><p>每个电控佬都知道keil的界面看代码是一件多么反人类的事情<br>如果不是因为他的仿真能力还有一些别的功能，怕是很多人老早就不用了。<br>但是，我们不能将就！我们要做一个有底线的嵌入式程序员！<br>这里感谢营东的方法提供和建议，结合我个人的摸索，最终形成了这套完整的Vscode内嵌入式开发流程<br>编译，烧录，仿真一气呵成，全部在Vscode里面搞定，彻底抛开keil！</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/DragonStart/p/12004523.html">OpenOCD+cmsis-Dap初始化</a></p><p><a href="https://flyfishzy.github.io/iotstudio-doc/zh/tutorial">Iot Links集成教程</a></p><p><a href="https://bbs.huaweicloud.com/forum/thread-23719-1-1.html">Iot Links调试器设置</a></p><p><a href="https://github.com/vllogic/openocd_cmsis-dap_v2">Dap-V2资料</a></p><p>部分重要插件下载地址：</p><p><a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD Download</a></p><p><a href="http://www.codeblocks.org/">CodeBlocks Download Site</a></p><p><a href="http://www.mingw.org/">Mingw Site</a></p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>在开始工作之前，你们需要准备以下的东西（上文有提供下载地址）：</p><ul><li>mingw或者CodeBlock，总之有gcc集成在里面就行</li><li>OpenOCD库</li><li>一份可爱的CubeMx生成的嵌入式代码（ToolChain/IDE选择为makefile）</li><li>一个可爱的Vscode，带C/C++插件</li><li>你的大脑和你的双手</li></ul><h2 id="手把手教学时间"><a href="#手把手教学时间" class="headerlink" title="手把手教学时间"></a>手把手教学时间</h2><h3 id="一、准备一份CubeMX代码"><a href="#一、准备一份CubeMX代码" class="headerlink" title="一、准备一份CubeMX代码"></a>一、准备一份CubeMX代码</h3><ul><li><p>打开你的CubeMx，生成一份代码，一切按照正常情况配置。</p></li><li><p>但是有一个地方需要更改的，就是在CubeMx的ToolChain/IDE选择界面</p></li><li><p>将ToolChain选择为Makefile，然后按照正常情况下导出生成即可。</p></li><li><p>如果可以的话，可以将Firmware Pac选择成为比较稳定的版本而不是最新版，防止由于版本不稳定出错而导致的debug的时候错误因素过多，难以排除的问题。</p></li></ul><p><img src="https://i.loli.net/2021/01/14/lkHmNOWdA6Kezbr.png" alt="对应界面"></p><h3 id="二、Vscode下载插件iot-Links，导入工程"><a href="#二、Vscode下载插件iot-Links，导入工程" class="headerlink" title="二、Vscode下载插件iot Links，导入工程"></a>二、Vscode下载插件iot Links，导入工程</h3><ol><li>打开Vscode，找到Adds（插件商店），搜索iot Links，并点击安装。</li></ol><ul><li><p>在成功安装之后，iot会自动的帮你安装他自带的工具链，等待他安装好就好</p></li><li><p><strong>切记在安装的时候不要切换到其他窗口，不然有可能会丢包导致后面出问题！（因为我尝试的时候就因为这个原因丢包了）</strong></p></li><li><p>成功安装之后，Vscode会提示说让你重启，跟着步骤重启就ok了！</p></li></ul><p><img src="https://i.loli.net/2021/01/14/rDRn5piMTcFVhl2.png" alt="iot Links界面"></p><ul><li>下载好后，点击Home回到iot主页面，点击导入GCC工程，将你生成的工程导入到Vscode中！</li></ul><h3 id="三、下载和配置OpenOCD库（如果你已经下载且配置好了请跳过这一步）"><a href="#三、下载和配置OpenOCD库（如果你已经下载且配置好了请跳过这一步）" class="headerlink" title="三、下载和配置OpenOCD库（如果你已经下载且配置好了请跳过这一步）"></a>三、下载和配置OpenOCD库（如果你已经下载且配置好了请跳过这一步）</h3><p>OOCD的库通过我上面给出的连接可以下载，下载好之后是一个压缩包。</p><p><img src="https://i.loli.net/2021/01/14/kjI2sFQY9BGpRuH.png" alt="OOCD界面"></p><p>将压缩包解压缩后，是这样子的一个子目录，为了保持步骤的完整，请你将目录点到和我图片目录一致后再进行下一步。（<strong>接下来的步骤请认真跟着做</strong>）</p><p><img src="https://i.loli.net/2021/01/14/p6mc3QuJoXl7N5B.png" alt="OOCD子目录界面"></p><h4 id="这里提供三种情况："><a href="#这里提供三种情况：" class="headerlink" title="这里提供三种情况："></a>这里提供三种情况：</h4><h4 id="如果你使用的是CMSIS-DAP设备进行烧录："><a href="#如果你使用的是CMSIS-DAP设备进行烧录：" class="headerlink" title="如果你使用的是CMSIS-DAP设备进行烧录："></a>如果你使用的是CMSIS-DAP设备进行烧录：</h4><ol><li>进入bin目录，在此目录空白区域，右键+shift，选择在此处打开powershell。</li></ol><p><img src="https://i.loli.net/2021/01/14/8JvyDZwXdIEm37B.png" alt="右键打开powershell"></p><ol start="2"><li>在powershell界面输入一下两条中的一条，根据你调试的板子决定。</li></ol><ul><li>注意，在进行此步骤之前，<strong>请将你的板子连着调试的设备接入你的电脑里面！</strong></li></ul><pre class=" language-C"><code class="language-C">./openocd -f interface/cmsis-dap.cfg -f target/stm32f1x.cfg./openocd -f interface/cmsis-dap.cfg -f target/stm32f4x.cfg</code></pre><ul><li>若出现一下输出，就是配置失败，这是请检查一下你的烧录器是否被检测到。（随便开个工程看看即可），或者连接线是否有问题。</li></ul><pre class=" language-C"><code class="language-C">Error: CMSIS-DAP command CMD_INFO failed.</code></pre><ul><li>若显示烧录器的info信息，则表明成功配置！</li></ul><p><img src="https://i.loli.net/2021/01/14/r9ypbDXxB1jn3EU.png" alt="OOCD中DAP激活连接成功"></p><ol start="3"><li>在Vscode中点击Home，打开iot Links主界面，选择iot Link设置，选择调试器，选择OOCD。</li></ol><ul><li>有两个参数需要你填入，<strong>一个是OOCD的路径，一个是OOCD的参数。</strong></li></ul><p><img src="https://i.loli.net/2021/01/14/5JAGW8MnIyfzCYN.png" alt="iot Link调试器设置"></p><ul><li>请在OOCD路径填入你刚刚<strong>右键打开PowerShell的目录的地址，加上一个openocd.exe。</strong></li><li>请在OOCD参数填入你<strong>刚刚激活板子的两个命令中你使用的那一条。</strong></li></ul><ol start="4"><li>将以下的三个地址加入电脑的环境变量中：</li></ol><p>（<strong>这里的…代表你的实际OOCD地址，而不是直接复制到环境变量中，请注意！</strong>）</p><ul><li>…\share\openocd\scripts\interface （烧录器支持库）</li><li>…\share\openocd\scripts\target （硬件支持库）</li><li>…\bin（就是你刚刚右键的地方）</li></ul><h4 id="如果你使用JLink设备进行烧录："><a href="#如果你使用JLink设备进行烧录：" class="headerlink" title="如果你使用JLink设备进行烧录："></a>如果你使用JLink设备进行烧录：</h4><p>请跳过这一步</p><h4 id="如果你使用除此以外的设备进行烧录："><a href="#如果你使用除此以外的设备进行烧录：" class="headerlink" title="如果你使用除此以外的设备进行烧录："></a>如果你使用除此以外的设备进行烧录：</h4><p>请等待后面的教程更新</p><h3 id="四、下载和配置CodeBlock集成库（如果你已经下载且配置好了请跳过这一步）"><a href="#四、下载和配置CodeBlock集成库（如果你已经下载且配置好了请跳过这一步）" class="headerlink" title="四、下载和配置CodeBlock集成库（如果你已经下载且配置好了请跳过这一步）"></a>四、下载和配置CodeBlock集成库（如果你已经下载且配置好了请跳过这一步）</h3><ol><li>CB的集成库通过我上面给出的连接可以下载，下载好之后是一个exe，安装软件即可</li></ol><ul><li><p><strong>如果不是安装在默认地址的话，请务必记住你安装CB时候的安装地址！</strong></p></li><li><p>如果是默认安装地址，那么就是C:\Program Files (x86)\CodeBlocks</p></li><li><p>打开安装好的地址，找到Mingw，并点入bin文件夹，复制你当前目录的目录地址</p></li><li><p><strong>将当前的目录地址加入环境变量</strong></p></li></ul><p><img src="https://i.loli.net/2021/01/14/8n6U9B5pEh4k2yX.png" alt="bin文件夹对应界面"></p><ol start="2"><li>回到刚刚导入工程的Vscode，选择.vscode文件夹里面自动生成的c_cpp_properties.json</li></ol><ul><li>将”compilerPath”：更换成为刚刚复制的地址 + /gcc.exe</li></ul><p><img src="https://i.loli.net/2021/01/14/T4KjgiJhNDBcUeA.png" alt="gcc编译器地址更改"></p><ol start="3"><li>在”defines”中将Keil编译器Debug中的C/C++上面的两个宏定义和四个基础宏定义填入。（不一定是两个，具体看你工程的情况）</li></ol><ul><li><p>以我的板子为例，我用的是F427的板子，那么在keil里面对应的宏定义为USE_HAL_DRIVER和STM32F427xx，在这里填入即可。不知道宏定义是什么的可以打开keil找找自己初始化的宏定义。</p></li><li><p>以我的板子为例，完全填入后为：</p></li></ul><pre class=" language-C"><code class="language-C">"defines": [                "_DEBUG",                "UNICODE",                "_UNICODE",                "__CC_ARM",                "USE_HAL_DRIVER",                "STM32F427xx"            ],</code></pre><p><img src="https://i.loli.net/2021/01/14/3QK47rHILyBzFlx.png" alt="Debug宏定义"></p><h3 id="五、配置-iotlink环境变量"><a href="#五、配置-iotlink环境变量" class="headerlink" title="五、配置.iotlink环境变量"></a>五、配置.iotlink环境变量</h3><ol><li>将以下的两个地址加入到对应的环境变量中：</li></ol><ul><li>（**…<strong>）为具体根据你电脑目前用户名决定（由于每个人用户名不同）。</strong>不能直接复制以下地址**）</li></ul><pre class=" language-C"><code class="language-C">C:\Users\...\.iotlink\tools\gcc-arm-none-eabi\binC:\Users\...\.iotlink\tools\gcc-arm-none-eabi\arm-none-eabi\bin</code></pre><p>至此，全部配置完成。</p><h2 id="开心测试功能时间"><a href="#开心测试功能时间" class="headerlink" title="开心测试功能时间"></a>开心测试功能时间</h2><h3 id="基础功能：编译、重编译、烧录"><a href="#基础功能：编译、重编译、烧录" class="headerlink" title="基础功能：编译、重编译、烧录"></a>基础功能：编译、重编译、烧录</h3><p>在Vscode的最底下可以找到对应的基本操作目录，对应如下：</p><p><img src="https://i.loli.net/2021/01/14/iR2H3dbVKvxIfqy.png" alt="操作界面"></p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul><li><p>点击编译，如果出现编译耗时字样，则说明编译成功。</p></li><li><p>首次编译时间会较长，但是实际上和keil差不多。</p></li></ul><p><img src="https://i.loli.net/2021/01/14/EhyAJ3vxsRQomzp.png" alt="编译成功界面"></p><h4 id="重编译"><a href="#重编译" class="headerlink" title="重编译"></a>重编译</h4><ul><li><p>点击重新编译，和编译相同，等待后出现耗时字样说明编译成功。</p></li><li><p>重新编译的时候，Vscode会把上一次的编译清理掉，请务必注意。</p></li></ul><p><img src="https://i.loli.net/2021/01/14/OW3I9QKipn26qMg.png" alt="重编译成功界面"></p><h4 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h4><ul><li><p>点击烧录按钮，然后等待即可，出现烧录成功提示即烧录成功（本人基于DAP测试成功）！</p></li><li><p>请记得打开板子电源烧录</p></li></ul><p><img src="https://i.loli.net/2021/01/14/cigRyuOSL2ArJ7z.png" alt="烧录成功"></p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li>调试功能要在Debug界面开启，iot自带了两个基础调试模式</li></ul><p><img src="https://i.loli.net/2021/01/14/fmkTRPdeUZqlHpC.png" alt="Debug界面开启"></p><ul><li><p>Launch模式就是重新启动代码，在main前面停下来等待用户点击开始运行，和keil里面的仿真方法一样。</p></li><li><p>Attach模式就是启动了之后代码直接跑。</p></li><li><p>PS：Vscode无法动态调试，<strong>请养成打log的好习惯</strong>！</p></li><li><p>什么叫无法动态调试：就是你添加了一个断点查看全局，然后你单步运行，监听的变量值没变，断点只能显示当前时刻的值，运行之后无法看到！</p></li><li><p>学会打log，能培养你debug啥能力，在赛场上或者运行过程也能也能分析你log的情况。</p></li><li><p>下一篇有机会的话会写一些打Log的方法，敬请期待！</p></li></ul><h4 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h4><ul><li>串口功能我还没尝试，以后会逐渐更新本教程！</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得本教程对你来说非常有用：</p><ol><li><p>分享给你身边的嵌入佬！大家一起Happy！</p></li><li><p>在文章的底下评论区写下疑惑和感想！我会根据疑惑和感想更新教程，谢谢你的反馈！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> iot Links </tag>
            
            <tag> STM32 IDE优化 </tag>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32基础概念速成</title>
      <link href="2020/01/13/STM32_All_in_One/"/>
      <url>2020/01/13/STM32_All_in_One/</url>
      
        <content type="html"><![CDATA[<h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><ol><li>本教程可用于概念复习，速成。</li><li>本教程只讲基于Robomaster和Robocon需要使用到的模块，很少用到的模块不会做特别说明（以教程实用性为主）。</li></ol><h2 id="基础概念和术语"><a href="#基础概念和术语" class="headerlink" title="基础概念和术语"></a>基础概念和术语</h2><p><strong>Stm32：</strong><br>32位微控制器，（位数越多，功能越多，功耗也可以越低，主核速度越快处理能力就越快）<br>Cortex-M3内核，是ARM公司的一款内核。</p><p><strong>电源（VBAT\VDD\VSS\VDDA\VSSA\VREF+\VRES-）：</strong><br>通常为纽扣电池，一般板子上面的这种字样代表其正极。<br>如果不确定是否正极，可以用电表直接测量两个引脚之间的电压差来确定对应的正负极。</p><p><strong>晶振IO：</strong><br>（OSC）（产生频率）主晶振IO，RTC晶振IO。</p><p><strong>下载IO：</strong><br>用于JTAG下载的IO：JTMS, JTCK,JTDI,TTDO,NJTRST。</p><p><strong>BOOT IO：</strong><br>BOOT0,BOOT1,用于设计启动方式，跳线帽的连接会导致其启动方式改变。</p><p><strong>复位IO：</strong><br>NRST用于外部的复位，上面的5部分IO叫最小系统。</p><p><strong>GPIO（宏义）：</strong><br>专用器件线，如I2C,SPI,SDIO,FSMC,DCMI,普通原件的GPIO,蜂鸣器，LED，KEY,以及其他的IO。</p><p><strong>Flash：</strong><br>掉电保护储存器（擦除次数有限）。</p><p><strong>SRAM：</strong><br>临时保护储存器（断电不保护）。</p><p><strong>常用工具和术语：</strong><br>参考手册：可以理解为官方的说明文档，可以看到所有对应模块的使用功能和相应的寄存器配置方式。<br>数据手册：能看到对应板子的具体的内存映射，引脚介绍。<br>原理图：能看到对应的引脚的封装的功能，每个引脚对应能干什么。<br>固件库：就是编写代码对应的使用库<br>库函数：对应的官方.h文件里面对应的封装好的函数。<br>寄存器：就是封装之后对应的位置的函数的应用。</p><h2 id="LED灯的点亮，GPIO的使用原理，GPIO输出应用"><a href="#LED灯的点亮，GPIO的使用原理，GPIO输出应用" class="headerlink" title="LED灯的点亮，GPIO的使用原理，GPIO输出应用"></a>LED灯的点亮，GPIO的使用原理，GPIO输出应用</h2><h3 id="基础原理说明"><a href="#基础原理说明" class="headerlink" title="基础原理说明"></a>基础原理说明</h3><p>GPIO是指板子中所有对应的引脚（即I/O口（或者说I/O引脚）），引脚能配置成为不同的输出方式，这里能直接使用LED灯是因为对应的引脚已经连接到识别灯上面，并被焊接到板子上面了，所以直接使能对应的引脚能使能LED灯。</p><h3 id="常见的输入输出模式详细解释"><a href="#常见的输入输出模式详细解释" class="headerlink" title="常见的输入输出模式详细解释"></a>常见的输入输出模式详细解释</h3><p>※常见的I/O输入和输出方式有以下八种：</p><p><strong>输入模式：</strong></p><ul><li>输入浮空（GPIO_Mode_IN_FLOATING）</li><li>输入上拉(GPIO_Mode_IPU)</li><li>输入下拉(GPIO_Mode_IPD)</li><li>模拟输入(GPIO_Mode_AIN)</li></ul><p><strong>输出模式：</strong></p><ul><li>开漏输出(GPIO_Mode_Out_OD)</li><li>开漏复用功能(GPIO_Mode_AF_OD)</li><li>推挽式输出(GPIO_Mode_Out_PP)</li><li>推挽式复用功能(GPIO_Mode_AF_PP)</li></ul><p><strong>详细解释：</strong></p><p>输入方式方面：</p><ol><li><p>输入浮空：</p><p> 浮空就是逻辑器件与引脚即不接高电平，也不接低电平。由于逻辑器件的内部结构，当它输入引脚悬空时，相当于该引脚接了高电平。一般实际运用时，引脚不建议悬空，易受干扰。通俗讲就是浮空就是浮在空中，就相当于此端口在默认情况下什么都不接，呈高阻态，这种设置在数据传输时用的比较多。浮空最大的特点就是电压的不确定性，它可能是0V，也可能是VCC，还可能是介于两者之间的某个值（最有可能） 浮空一般用来做ADC输入用，这样可以减少上下拉电阻对结果的影响。</p></li><li><p>输入上拉模式：</p><p> 上拉就是把点位拉高，比如拉到Vcc。上拉就是将不确定的信号通过一个电阻嵌位在高电平。电阻同时起到限流的作用。弱强只是上拉电阻的阻值不同，没有什么严格区分。可以理解为上拉就是在没有输入信号的时候，I/O口的状态为1（也就是高电平）。</p></li><li><p>输入下拉：</p><p> 就是把电压拉低，拉到GND。与上拉原理相似。可以理解为下拉就是在没有输入信号的时候，I/O口的状态为0（也就是低电平）。</p></li><li><p>模拟输入：</p><p> 模拟输入是指传统方式的输入，数字输入是输入PCM数字信号，即0,1的二进制数字信号，通过数模转换，转换成模拟信号，经前级放大进入功率放大器，功率放大器还是模拟的。可以理解为将本来离散的变量转换为连接变化态的模拟量（离散点转换成为一条平滑的曲线）。</p></li></ol><p><strong>输出方式方面：</strong></p><ol><li><p>开漏输出：</p><p> 输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行，适合于做电流型的驱动，其吸收电流的能力相对强（一般20mA以内）。<br> 可以理解为，当内部想要输出的电平为1（高电平）的时候，对应的MOS管被截止了，此时I/O口其实是没有驱动能力的，为高阻态，需要外部连接上拉电阻才可以实现高电平，才可以驱动数字器件。内部输出为0（低电平）的时候，MOS管导通，I/O口输出为低电平。一下是对应的开漏输出的对应参考图。</p></li><li><p>开漏复用功能：</p><p> 可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）。端口必须配置成复用功能输出模式（推挽或开漏）。具体I/O口被用作第二功能的时候，对应的第二功能可以在原理图里面查看。</p></li><li><p>推挽式输出：</p><p> 可以输出高，低电平，连接数字器件;推挽结构一般是指两个三级管分别受到互补信号的控制，总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。推挽电路是两个参数相同的三极管或MOSFET，以推挽方式存在于电路中，各负责正负半周的波形方法任务，电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小，效率高。输出即可以向负载灌电流。推拉式输出级即提高电路的负载能力，又提高开关速度。一下是推挽输出的示意图。</p></li><li><p>推挽式复用功能：</p><p> 可以理解为GPIO口被用作第二功能时的配置情况（并非作为通用IO口使用）</p></li></ol><h3 id="常见的输入输出简单解释"><a href="#常见的输入输出简单解释" class="headerlink" title="常见的输入输出简单解释"></a>常见的输入输出简单解释</h3><p><strong>猴子都可以看得懂的人话解释：</strong></p><p>输入模式</p><ul><li>输入浮空（GPIO_Mode_IN_FLOATING）：浮空输入，啥都不接，可以用作KEY识别，RX</li><li>输入上拉(GPIO_Mode_IPU)：上拉电阻，不接东西的时候默认状态为1</li><li>输入下拉(GPIO_Mode_IPD)：下拉电阻，不接东西的时候默认状态为0</li><li>模拟输入(GPIO_Mode_AIN)：散点变成一条平滑的曲线，应用在ADC里面的模拟输入，或者低功耗下面省电</li></ul><p>输出模式</p><ul><li>开漏输出(GPIO_Mode_Out_OD)：输出0的时候相当于接GND，输出1的时候相当于浮空（高阻态），需要外接上拉才可以实现高电平。可以通过外部设备的上下拉控制内部设备的高低电平状态，实现双向控制。</li><li>开漏复用功能(GPIO_Mode_AF_OD)：同上，不过会换个功能。</li><li>推挽式输出(GPIO_Mode_Out_PP)：输出0等于接GND，输出1等于接VCC</li><li>推挽式复用功能(GPIO_Mode_AF_PP)：同上，换个功能。</li></ul><p><strong>使能对应的功能之前需要相应的配置，小学生都知道开门之前要先找到对应的钥匙。</strong></p><p>以下是参考代码（基于基本库）：</p><pre class=" language-C"><code class="language-C">//初始化灯void GPIO_QuickInit(void){    GPIO_InitTypeDef GPIO_InitStructure;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD,ENABLE);    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_12;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&GPIO_InitStructure);    GPIO_SetBits(GPIOA,GPIO_Pin_12);    }</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>注意，LED灯是低电平的时候亮，高电平的时候不亮</li><li>使用的时候注意配置头文件的包含关系，不要循环包含，否则在编译情况下有可能会出现报错的情况。</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> STM32速成 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
